<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (LAGUNA) - Chapter 2: A sample calculation with LAGUNA</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap1.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap3.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X7AAB1F18838B1DAB" name="X7AAB1F18838B1DAB"></a></p>
<div class="ChapSects"><a href="chap2.html#X7AAB1F18838B1DAB">2 <span class="Heading">A sample calculation with <strong class="pkg">LAGUNA</strong></span></a>
</div>

<h3>2 <span class="Heading">A sample calculation with <strong class="pkg">LAGUNA</strong></span></h3>

<p>Before explaining the theory behind the <strong class="pkg">LAGUNA</strong> package we present a sample calculation to show the reader what <strong class="pkg">LAGUNA</strong> is able to compute. We will carry out some calculations in the group algebra of the dihedral group of order 16 over the field of two elements. First we create this modular group algebra.</p>


<table class="example">
<tr><td><pre>

gap&gt; K := GF( 2 );
GF(2)
gap&gt; G := DihedralGroup( 16 );
&lt;pc group of size 16 with 4 generators&gt;
gap&gt; KG := GroupRing( K, G );
&lt;algebra-with-one over GF(2), with 4 generators&gt;

</pre></td></tr></table>

<p>The group algebra <code class="code">KG</code> has some properties and attributes that are direct consequences of its definition. These can be checked very quickly.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsGroupAlgebra( KG ); 
true
gap&gt; IsPModularGroupAlgebra( KG );
true
gap&gt; IsFModularGroupAlgebra( KG );
true
gap&gt; UnderlyingGroup( KG );
&lt;pc group of size 16 with 4 generators&gt;
gap&gt; LeftActingDomain( KG );
GF(2)

</pre></td></tr></table>

<p>Since <code class="code">KG</code> is naturally a group algebra, the information provided by <code class="code">LeftActingDomain</code> can also be obtained using two other functions as follows.</p>


<table class="example">
<tr><td><pre>
gap&gt; UnderlyingRing( KG );
GF(2)
gap&gt; UnderlyingField( KG );
GF(2)
</pre></td></tr></table>

<p>Let us construct a certain element of the group algebra. For example, we take a minimal generating system of the group <code class="code">G</code> and find the corresponding elements in <code class="code">KG</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; MinimalGeneratingSet( G );
[ f1, f2 ]
gap&gt; l := List( last, g -&gt; g^Embedding( G, KG ) );
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]

</pre></td></tr></table>

<p>Now we construct an element <code class="code">x</code> as follows.</p>


<table class="example">
<tr><td><pre>

gap&gt; a :=l[1]; b:=l[2]; # a and b are images of group generators in KG
(Z(2)^0)*f1
(Z(2)^0)*f2
gap&gt; e := One( KG );    # for convenience, we denote the identity by e
(Z(2)^0)*&lt;identity&gt; of ...
gap&gt; x := ( e + a ) * ( e + b ); 
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2  

</pre></td></tr></table>

<p>We may investigate some of the basic properties of our element.</p>


<table class="example">
<tr><td><pre>

gap&gt; Support( x );
[ &lt;identity&gt; of ..., f1, f2, f1*f2 ]
gap&gt; CoefficientsBySupport( x );
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
gap&gt; Length( x );
4
gap&gt; TraceOfMagmaRingElement( x );
Z(2)^0

</pre></td></tr></table>

<p>We can also calculate the augmentation of <code class="code">x</code>, which is defined as the sum of its coefficients.</p>


<table class="example">
<tr><td><pre>
gap&gt; Augmentation( x );
0*Z(2)
gap&gt; IsUnit( KG, x );
false
</pre></td></tr></table>

<p>Since the augmentation of <code class="code">x</code> is zero, <code class="code">x</code> is not invertible, but <code class="code">1+x</code> is. This is again very easy to check.</p>


<table class="example">
<tr><td><pre>

gap&gt; y := e + x;
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; IsUnit( KG, y );
true  

</pre></td></tr></table>

<p><strong class="pkg">LAGUNA</strong> can calculate the inverse of <code class="code">1+x</code> very quickly.</p>


<table class="example">
<tr><td><pre>

gap&gt; y^-1;
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f4+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(
Z(2)^0)*f1*f2*f3*f4
gap&gt; y * y^-1;
(Z(2)^0)*&lt;identity&gt; of ... 

</pre></td></tr></table>

<p>We may also want to check whether <code class="code">y</code> is symmetric, that is, whether it is invariant under the classical involution; or whether it is unitary, that is, whether the classical involution inverts <code class="code">y</code>. We find that <code class="code">y</code> is neither.</p>


<table class="example">
<tr><td><pre>

gap&gt; Involution( y );
(Z(2)^0)*f1+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3*f4
gap&gt; y = Involution( y );
false
gap&gt; IsSymmetric( y );
false
gap&gt; y * Involution( y );
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f2+(Z(2)^0)*f2*f3*f4  
gap&gt; IsUnitary( y );
false

</pre></td></tr></table>

<p>Now we calculate some important ideals of <code class="code">KG</code>. First we obtain the augmentation ideal which is the set of elements with augmentation zero. In our case the augmentation ideal of <code class="code">KG</code> coincides with the radical of <code class="code">KG</code>, and this is taken into account in <strong class="pkg">LAGUNA</strong>.</p>


<table class="example">
<tr><td><pre>

gap&gt; AugmentationIdeal( KG );
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 15)&gt;
gap&gt; RadicalOfAlgebra( KG ) = AugmentationIdeal( KG );
true

</pre></td></tr></table>

<p>It is well-known that the augmentation ideal of <code class="code">KG</code> is a nilpotent ideal. Using Jennings' theory on dimension subgroups, we can obtain its nilpotency index without immediate calculation of its powers. This is implemented in <strong class="pkg">LAGUNA</strong>.</p>


<table class="example">
<tr><td><pre>
gap&gt; AugmentationIdealNilpotencyIndex( KG );
9
</pre></td></tr></table>

<p>On the other hand, we can also calculate the powers of the augmentation ideal.</p>


<table class="example">
<tr><td><pre>

gap&gt; AugmentationIdealPowerSeries( KG );
[ &lt;algebra of dimension 15 over GF(2)&gt;, &lt;algebra of dimension 13 over GF(2)&gt;, 
  &lt;algebra of dimension 11 over GF(2)&gt;, &lt;algebra of dimension 9 over GF(2)&gt;, 
  &lt;algebra of dimension 7 over GF(2)&gt;, &lt;algebra of dimension 5 over GF(2)&gt;, 
  &lt;algebra of dimension 3 over GF(2)&gt;, &lt;algebra of dimension 1 over GF(2)&gt;, 
  &lt;algebra over GF(2)&gt; ]

</pre></td></tr></table>

<p>We see that the length of this list is exactly the nilpotency index of the augmentation ideal of <code class="code">KG</code>.</p>

<p>Now let's work with the unit group of <code class="code">KG</code>. First we calculate the normalized unit group, which is the set of elements with augmentation one. The generators of the unit group are obtained as explained in Chapter <a href="chap3.html#X7D9FCE3A8526ACBE"><b>3</b></a>. This can be computed very quickly, but further computation with this group is very inefficient.</p>


<table class="example">
<tr><td><pre>

gap&gt; V := NormalizedUnitGroup( KG );
&lt;group of size 32768 with 15 generators&gt;   

</pre></td></tr></table>

<p>In order to make our computation in the normalised unit group efficient, we calculate a power-commutator presentation for this group.</p>


<table class="example">
<tr><td><pre>

gap&gt; W := PcNormalizedUnitGroup( KG );
&lt;pc group of size 32768 with 15 generators&gt;

</pre></td></tr></table>

<p><strong class="pkg">GAP</strong> has many efficient and practical algorithms for groups given by a power-commutator presentation. In order to use these algorithms to carry out computation in the normalised unit group, we need to set up isomorphisms between the outputs of <code class="code">NormalizedUnitGroup</code> and <code class="code">PcNormalizedUnitGroup</code>.</p>

<p>The first isomorphism maps <code class="code">NormalizedUnitGroup(KG)</code> onto the polycyclically presented <code class="code">PcNormalizedUnitGroup(PC)</code>. Let's find the images of the elements of the group <code class="code">G</code> in <code class="code">W</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; t := NaturalBijectionToPcNormalizedUnitGroup( KG );
MappingByFunction( &lt;group of size 32768 with
15 generators&gt;, &lt;pc group of size 32768 with
15 generators&gt;, function( x ) ... end )
gap&gt; List( AsList( G ), x -&gt; ( x^Embedding( G, KG ) )^t );
[ &lt;identity&gt; of ..., f2, f1, f3, f7, f1*f2*f3, f2*f3, f2*f7, f1*f3, f1*f7,
  f3*f7, f1*f2*f7, f1*f2*f3*f7, f2*f3*f7, f1*f3*f7, f1*f2 ]

</pre></td></tr></table>

<p>The second isomorphism is the inverse of the first.</p>


<table class="example">
<tr><td><pre>
gap&gt; f := NaturalBijectionToNormalizedUnitGroup( KG );
[ f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15 ] -&gt;
[ (Z(2)^0)*f2, (Z(2)^0)*f1, (Z(2)^0)*f3,
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2,
  (Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f2*f3,
  (Z(2)^0)*f1+(Z(2)^0)*f3+(Z(2)^0)*f1*f3, (Z(2)^0)*f4,
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f3+(Z(2)^
    0)*f2*f3+(Z(2)^0)*f1*f2*f3, (Z(2)^0)*f2+(Z(2)^0)*f4+(Z(2)^0)*f2*f4,
  (Z(2)^0)*f1+(Z(2)^0)*f4+(Z(2)^0)*f1*f4,
  (Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f3*f4,
  (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f4+(Z(2)^
    0)*f2*f4+(Z(2)^0)*f1*f2*f4, (Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^
    0)*f2*f3+(Z(2)^0)*f2*f4+(Z(2)^0)*f3*f4+(Z(2)^0)*f2*f3*f4,
  (Z(2)^0)*f1+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^
    0)*f3*f4+(Z(2)^0)*f1*f3*f4, (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^
    0)*f4+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^
    0)*f2*f4+(Z(2)^0)*f3*f4+(Z(2)^0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^
    0)*f1*f3*f4+(Z(2)^0)*f2*f3*f4+(Z(2)^0)*f1*f2*f3*f4 ]
</pre></td></tr></table>

<p>For example, we may calculate the conjugacy classes of the group <code class="code">W</code>, and then map their representatives back into the group algebra.</p>


<table class="example">
<tr><td><pre>

gap&gt; cc := ConjugacyClasses( W );;
gap&gt; Length( cc );
848
gap&gt; Representative( cc[ Length( cc ) ] );
f1*f2*f4*f6*f12*f15
gap&gt; last^f;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f2+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(Z(2)^0)*f3*f4+(Z(2)^
0)*f1*f2*f3+(Z(2)^0)*f1*f3*f4

</pre></td></tr></table>

<p>Having a power-commutator presentation of the normalised unit group, we may use the full power of the <strong class="pkg">GAP</strong> functionality for such groups. For example, the lower central series can be calculated very quickly.</p>


<table class="example">
<tr><td><pre>

gap&gt; LowerCentralSeries( W );
[ &lt;pc group of size 32768 with 15 generators&gt;,
  Group([ f3, f5*f8*f10*f12*f13*f14*f15, f6*f8*f12*f14*f15, f7, f9*f12,
      f10*f14, f11*f13, f13*f14, f14*f15 ]),
  Group([ f7, f9*f12, f10*f15, f11*f15, f13*f15, f14*f15 ]),
  Group([ f11*f15, f13*f15, f14*f15 ]), Group([ &lt;identity&gt; of ... ]) ]

</pre></td></tr></table>

<p>Let's now compute, for instance, a minimal system of generators of the centre of the normalised unit group. First we carry out the computation in the group which is determined by the power-commutator presentation, then we map the result into our group algebra.</p>


<table class="example">
<tr><td><pre>

gap&gt; C := Centre( W );
Group([ f3*f5*f13*f15, f7, f15, f13*f15, f14*f15, f11*f13*f14*f15 ])
gap&gt; m := MinimalGeneratingSet( C );
[ f7*f13*f14*f15, f13*f14*f15, f7*f11*f14*f15, f15, f3*f5*f14 ]
gap&gt; List( m, g -&gt; g^f );
[ (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^0)*f3*f4+(Z(2)^
    0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f1*f2*f3*f4,
  (Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^0)*f3*f4+(Z(2)^0)*f1*f2*f3+(
    Z(2)^0)*f1*f2*f4+(Z(2)^0)*f1*f2*f3*f4, (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^
    0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(Z(2)^
    0)*f3*f4+(Z(2)^0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(Z(2)^
    0)*f1*f2*f3*f4, (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^
    0)*f1*f2+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(
    Z(2)^0)*f3*f4+(Z(2)^0)*f1*f2*f3+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f1*f3*f4+(Z(2)^
    0)*f2*f3*f4+(Z(2)^0)*f1*f2*f3*f4, (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(
    Z(2)^0)*f3+(Z(2)^0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f3+(Z(2)^0)*f2*f4+(
    Z(2)^0)*f3*f4+(Z(2)^0)*f1*f3*f4 ]

</pre></td></tr></table>

<p>We finish our example by calculating some properties of the Lie algebra associated with <code class="code">KG</code>. This example needs no further explanation.</p>


<table class="example">
<tr><td><pre>

gap&gt; L := LieAlgebra( KG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; D := LieDerivedSubalgebra( L );
#I  LAGUNA package: Computing the Lie derived subalgebra ...
&lt;Lie algebra of dimension 9 over GF(2)&gt;
gap&gt; LC := LieCentre( L );
&lt;Lie algebra of dimension 7 over GF(2)&gt;
gap&gt; LieLowerNilpotencyIndex( KG );
5
gap&gt; LieUpperNilpotencyIndex( KG );
5
gap&gt; IsLieAbelian( L );
false
gap&gt; IsLieSolvable( L );
#I  LAGUNA package: Checking Lie solvability ...
true
gap&gt; IsLieMetabelian( L );
false
gap&gt; IsLieCentreByMetabelian( L );
true

</pre></td></tr></table>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap1.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap3.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
