<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (LAGUNA) - Chapter 4: LAGUNA functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap3.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chapBib.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X7F79B2207E293F2B" name="X7F79B2207E293F2B"></a></p>
<div class="ChapSects"><a href="chap4.html#X7F79B2207E293F2B">4 <span class="Heading"><strong class="pkg">LAGUNA</strong> functions</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap4.html#X7B473F157842958E">4.1 <span class="Heading">General functions for group algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X861A702283A667DF">4.1-1 IsGroupAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X82DBCA8F7DB21AC5">4.1-2 IsFModularGroupAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X849599E07C38A739">4.1-3 IsPModularGroupAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C966B177BB62C72">4.1-4 UnderlyingGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8534C18E7EA81CB8">4.1-5 UnderlyingRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X790470C48340E8F7">4.1-6 UnderlyingField</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap4.html#X81DC99ED7AC03E46">4.2 <span class="Heading">Operations with group algebra elements</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B689C0284AC4296">4.2-1 Support</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8401D79C8678D3FA">4.2-2 CoefficientsBySupport</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X81DD298A7C06EC82">4.2-3 TraceOfMagmaRingElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X780769238600AFD1">4.2-4 Length</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X86FA17BE858F2245">4.2-5 Augmentation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X83A318C887B3E735">4.2-6 PartialAugmentations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X81EB2A0A8756372B">4.2-7 Involution</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X82D0BA3D7D3994F6">4.2-8 IsSymmetric</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7990BD877E89A9EC">4.2-9 IsUnitary</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X85CBFBAE78DE72E8">4.2-10 IsUnit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X82EC4F49877D6EB1">4.2-11 InverseOp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7FD01F52845445EC">4.2-12 BicyclicUnitOfType1</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8631AD178508D219">4.2-13 BassCyclicUnit</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap4.html#X841733AB86D30446">4.3 <span class="Heading">Important attributes of group algebras</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7F7FD75E84BEE0EF">4.3-1 AugmentationHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B21DB3E7CD80983">4.3-2 AugmentationIdeal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X850C29907A509533">4.3-3 RadicalOfAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8292BEFC7922E773">4.3-4 WeightedBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X84B25D3A812A8A2E">4.3-5 AugmentationIdealPowerSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8567023A821E39A6">4.3-6 AugmentationIdealNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C0D5F3C842302EC">4.3-7 AugmentationIdealOfDerivedSubgroupNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X837294D57E415E37">4.3-8 LeftIdealBySubgroup</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap4.html#X863248708784F94C">4.4 <span class="Heading">Computations with the unit group</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X817D5AC78754527F">4.4-1 NormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7D40E42A7B678598">4.4-2 PcNormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E08F6E87C586A36">4.4-3 NaturalBijectionToPcNormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X83715EF37B9FA94A">4.4-4 NaturalBijectionToNormalizedUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X84D64AF17941FA7F">4.4-5 Embedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X853C045B7BA6A580">4.4-6 Units</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E67BDA77E5E6077">4.4-7 PcUnits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7F2532888184CB22">4.4-8 IsGroupOfUnitsOfMagmaRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7EF9BF297A9412AB">4.4-9 IsUnitGroupOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X82AC131384191CCE">4.4-10 IsNormalizedUnitGroupOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X82DCA8A57D0D1114">4.4-11 UnderlyingGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7A0FFABC86F89517">4.4-12 UnitarySubgroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X859F07AE7A4D317B">4.4-13 BicyclicUnitGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7A39E44D87CDF7B0">4.4-14 GroupBases</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap4.html#X783C1A3D86A6656B">4.5 <span class="Heading">The Lie algebra of a group algebra</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7827B4158459DEA0">4.5-1 LieAlgebraByDomain</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7AA7DA6082639B23">4.5-2 IsLieAlgebraByAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X85F4712B84624DB8">4.5-3 UnderlyingAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X84050A268514F2EE">4.5-4 NaturalBijectionToLieAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X821DAFD585EA1DF3">4.5-5 NaturalBijectionToAssociativeAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X78C26E3F80E55AC2">4.5-6 IsLieAlgebraOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X87CCD17A790BE256">4.5-7 UnderlyingGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X833439F7846784B5">4.5-8 Embedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8111F58E7DE3E25C">4.5-9 LieCentre</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C95C0057C977747">4.5-10 LieDerivedSubalgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7F97D08F7B738ADE">4.5-11 IsLieAbelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X859FF1B3812B8FCC">4.5-12 IsLieSolvable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X78452F4E875A62A8">4.5-13 IsLieNilpotent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X8504EC257B764BA6">4.5-14 IsLieMetabelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7EEAA09F818CE548">4.5-15 IsLieCentreByMetabelian</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7C8EBFF5805F8C51">4.5-16 CanonicalBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X83026DFF8461B96D">4.5-17 IsBasisOfLieAlgebraOfGroupRing</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X804ADF0280F67CDC">4.5-18 StructureConstantsTable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X87E9411284D1A346">4.5-19 LieUpperNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7D71DF0579FBE1C9">4.5-20 LieLowerNilpotencyIndex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E5950517F0CDB47">4.5-21 LieDerivedLength</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap4.html#X7B16423A7FBED034">4.6 <span class="Heading">Other commands</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X85CE6B407910F768">4.6-1 SubgroupsOfIndexTwo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7AFBD42180787A07">4.6-2 DihedralDepth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7D7CD02F803FFC08">4.6-3 DimensionBasis</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X84B7C6A38473722F">4.6-4 LieDimensionSubgroups</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7B2EAF81791D6C68">4.6-5 LieUpperCodimensionSeries</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E5804B881DE4FF2">4.6-6 LAGInfo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X7E812CAB85104F42">4.6-7 LAGUNABuildManual</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4.html#X86E5260678EDF23D">4.6-8 LAGUNABuildManualHTML</a></span>
</div>
</div>

<h3>4 <span class="Heading"><strong class="pkg">LAGUNA</strong> functions</span></h3>

<p><a id="X7B473F157842958E" name="X7B473F157842958E"></a></p>

<h4>4.1 <span class="Heading">General functions for group algebras</span></h4>

<p><a id="X861A702283A667DF" name="X861A702283A667DF"></a></p>

<h5>4.1-1 IsGroupAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsGroupAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>A group ring over a field is called a group algebra. For a group ring <var class="Arg">KG</var>, <code class="code">IsGroupAlgebra</code> returns <code class="keyw">true</code>, if the underlying ring of <var class="Arg">KG</var> is a field; <code class="keyw">false</code> is returned otherwise. This property will be set automatically for every group ring created by the function <code class="code">GroupRing</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsGroupAlgebra( GroupRing( GF( 2 ), DihedralGroup( 16 ) ) );
true
gap&gt; IsGroupAlgebra( GroupRing( Integers, DihedralGroup( 16 ) ) );
false      

</pre></td></tr></table>

<p><a id="X82DBCA8F7DB21AC5" name="X82DBCA8F7DB21AC5"></a></p>

<h5>4.1-2 IsFModularGroupAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsFModularGroupAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>A group algebra KG over a field K is called <em>modular</em>, if the characteristic of the field K divides the order of some element in G. For a group algebra <var class="Arg">KG</var> of a finite group G, <code class="code">IsModularGroupAlgebra</code> returns <code class="keyw">true</code>, if <var class="Arg">KG</var> is modular according to this definition; <code class="keyw">false</code> is returned otherwise. This property will be set automatically for every group algebra, created by the function <code class="code">GroupRing</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsFModularGroupAlgebra( GroupRing( GF( 2 ), SymmetricGroup( 6 ) ) );
true
gap&gt; IsFModularGroupAlgebra( GroupRing( GF( 2 ), CyclicGroup( 3 ) ) );
false  

</pre></td></tr></table>

<p><a id="X849599E07C38A739" name="X849599E07C38A739"></a></p>

<h5>4.1-3 IsPModularGroupAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsPModularGroupAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>A group algebra KG is said to be p-modular, if K is a field of characteristic p and G is a finite p-group for the same prime p. For a group algebra <var class="Arg">KG</var> of a finite group G, <code class="code">IsPModularGroupAlgebra</code> returns <code class="keyw">true</code>, if <var class="Arg">KG</var> is p-modular according to this definition; <code class="keyw">false</code> is returned otherwise. This property will be set automatically for every group algebra, created by the function <code class="code">GroupRing</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsPModularGroupAlgebra( GroupRing( GF( 2 ), DihedralGroup( 16 ) ) );
true
gap&gt; IsPModularGroupAlgebra( GroupRing( GF( 2 ), SymmetricGroup( 6 ) ) );
false        

</pre></td></tr></table>

<p><a id="X7C966B177BB62C72" name="X7C966B177BB62C72"></a></p>

<h5>4.1-4 UnderlyingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the underlying group of a group ring</p>

<p>This attribute stores the underlying group of a group ring <var class="Arg">KG</var>. In fact, it refers to the attribute <code class="code">UnderlyingMagma</code> which returns the same result, and was introduced for group rings for convenience, and for teaching purposes.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF ( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; G := UnderlyingGroup( KG );
&lt;pc group of size 16 with 4 generators&gt;  

</pre></td></tr></table>

<p><a id="X8534C18E7EA81CB8" name="X8534C18E7EA81CB8"></a></p>

<h5>4.1-5 UnderlyingRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingRing</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the underlying ring of a group ring</p>

<p>This attribute stores the underlying ring of a group ring <var class="Arg">KG</var>. In fact, it refers to the attribute <code class="code">LeftActingDomain</code> which returns the same result, and was introduced for group rings for convenience, and for teaching purposes.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; UnderlyingRing( KG );
GF(2)     

</pre></td></tr></table>

<p><a id="X790470C48340E8F7" name="X790470C48340E8F7"></a></p>

<h5>4.1-6 UnderlyingField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingField</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the underlying field of a group algebra</p>

<p>This attribute stores the underlying field of a group algebra <var class="Arg">KG</var>. In fact, it refers to the attribute <code class="code">LeftActingDomain</code> which returns the same result, and was introduced for group algebras for convenience, and for teaching purposes.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; UnderlyingField( KG );
GF(2)    

</pre></td></tr></table>

<p><a id="X81DC99ED7AC03E46" name="X81DC99ED7AC03E46"></a></p>

<h4>4.2 <span class="Heading">Operations with group algebra elements</span></h4>

<p><a id="X7B689C0284AC4296" name="X7B689C0284AC4296"></a></p>

<h5>4.2-1 Support</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Support</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>support of x as a list of elements of the underlying group</p>

<p>Returns the support of a group ring element <var class="Arg">x</var>. The support of a non-zero element x = alpha_1 * g_1 + alpha_2 * g_2 + cdots + alpha_k * g_k of a group ring is the list of elements g_i in G for which the coefficient alpha_i is non-zero. The support of the zero element of a group ring is defined to be the empty list. This method is also applicable to elements of magma rings.</p>


<table class="example">
<tr><td><pre>

# First we create an element x to use in in the series of examples.
# We map the minimal generating system of the group G to its group algebra
# and denote their images as a and b
gap&gt; G:=DihedralGroup(16);; KG:=GroupRing(GF(2),G);;
gap&gt; l := List( MinimalGeneratingSet( G ), g -&gt; g^Embedding( G, KG ) );
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
gap&gt; a := l[1]; b := l[2]; e := One( KG ); # we denote the identity by e
(Z(2)^0)*f1
(Z(2)^0)*f2
(Z(2)^0)*&lt;identity&gt; of ...
gap&gt; x := ( e + a ) * ( e + b );
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; Support( x );
[ &lt;identity&gt; of ..., f1, f2, f1*f2 ]     

</pre></td></tr></table>

<p><a id="X8401D79C8678D3FA" name="X8401D79C8678D3FA"></a></p>

<h5>4.2-2 CoefficientsBySupport</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CoefficientsBySupport</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>coefficients of support elements as list of elements of the underlying ring</p>

<p>Returns a list that contains the coefficients corresponding to the elements of <code class="code">Support( x )</code> in the same order as the elements appear in <code class="code">Support( x )</code>. This method is also applicable to elements of magma rings.</p>


<table class="example">
<tr><td><pre>

gap&gt; x;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; CoefficientsBySupport( x );
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]   

</pre></td></tr></table>

<p><a id="X81DD298A7C06EC82" name="X81DD298A7C06EC82"></a></p>

<h5>4.2-3 TraceOfMagmaRingElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TraceOfMagmaRingElement</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>an element of the underlying ring</p>

<p>Returns the trace of a group ring element <var class="Arg">x</var>. By definition, the trace of an element x = alpha_1 * 1 + alpha_2 * g_2 + cdots + alpha_k * g_k is equal to alpha_1, that is, the coefficient of the identity element in G. The trace of the zero element is zero. This method is also applicable to elements of magma rings.</p>


<table class="example">
<tr><td><pre>

gap&gt; x;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; TraceOfMagmaRingElement( x );
Z(2)^0        

</pre></td></tr></table>

<p><a id="X780769238600AFD1" name="X780769238600AFD1"></a></p>

<h5>4.2-4 Length</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Length</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>The length of an element of a group ring <var class="Arg">x</var> is defined as the number of elements in its support. This method is also applicable to elements of magma rings.</p>


<table class="example">
<tr><td><pre>

gap&gt; x;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; Length( x );
4     

</pre></td></tr></table>

<p><a id="X86FA17BE858F2245" name="X86FA17BE858F2245"></a></p>

<h5>4.2-5 Augmentation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Augmentation</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the sum of coefficients of a group ring element</p>

<p>The augmentation of a group ring element x = alpha_1 * g_1 + alpha_2 * g_2 + cdots + alpha_k * g_k is the sum of its coefficients alpha_1 + alpha_2 + cdots + alpha_k. The method is also applicable to elements of magma rings.</p>


<table class="example">
<tr><td><pre>

gap&gt; x;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; Augmentation( x );
0*Z(2)     

</pre></td></tr></table>

<p><a id="X83A318C887B3E735" name="X83A318C887B3E735"></a></p>

<h5>4.2-6 PartialAugmentations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PartialAugmentations</code>( <var class="Arg">KG, x</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a list of partial augmentations and a list of conjugacy class representatives</p>

<p>The partial augmentation of an element x = alpha_1 * g_1 + alpha_2 * g_2 + cdots + alpha_k * g_k of the group ring KG, corresponding to the conjugacy class of an element g from the underlying group G is the sum of coefficients alpha_i taken over all g_i such that g_i is conjugated to g. The function returns a list of two lists, the first one is a list of partial augmentations, and the second is a list of representatives of appropriate conjugacy classes of elements of the group G.</p>


<table class="example">
<tr><td><pre>

gap&gt; y := x + a*b^2;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2+(Z(2)^
0)*f1*f3
gap&gt; PartialAugmentations( KG, y );
[ [ Z(2)^0, 0*Z(2), Z(2)^0, Z(2)^0 ], [ &lt;identity&gt; of ..., f1, f2, f1*f2 ] ]    

</pre></td></tr></table>

<p><a id="X81EB2A0A8756372B" name="X81EB2A0A8756372B"></a></p>

<h5>4.2-7 Involution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Involution</code>( <var class="Arg">x[, f]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>an element of a group ring</p>

<p>Let KG be a group ring and let f be a mapping G -&gt; G, such that f^2 is the identity mapping on G. Then the involution of KG induced by f is defined by alpha_1 * g_1 + alpha_2 * g_2 + cdots + alpha_k * g_k -&gt; alpha_1 * f(g_1) + alpha_2 * f(g_2) + cdots + alpha_k * f(g_k). This method returns the image of <var class="Arg">x</var> under the involution of KG with respect to <var class="Arg">f</var>.</p>

<p>If the second argument is omitted, the function returns the result of the so-called classical involution, which is the involution induced by the map x -&gt; x^-1.</p>


<table class="example">
<tr><td><pre>

gap&gt; x;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; Involution( x );
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3*f4
# let's check the action of involution on elements from the group G
gap&gt; l := List( MinimalGeneratingSet( G ), g -&gt; g^Embedding( G, KG ) );
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
gap&gt; List( l, Involution );
[ (Z(2)^0)*f1, (Z(2)^0)*f2*f3*f4 ]
gap&gt; List( l, g -&gt; g^-1 );
[ (Z(2)^0)*f1, (Z(2)^0)*f2*f3*f4 ]     

</pre></td></tr></table>

<p><a id="X82D0BA3D7D3994F6" name="X82D0BA3D7D3994F6"></a></p>

<h5>4.2-8 IsSymmetric</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsSymmetric</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>An element of a group ring is called <em>symmetric</em> if it is fixed under the classical involution. This property is checked here.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsSymmetric( x );
false
gap&gt; IsSymmetric( x * Involution( x ) );
true     

</pre></td></tr></table>

<p><a id="X7990BD877E89A9EC" name="X7990BD877E89A9EC"></a></p>

<h5>4.2-9 IsUnitary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsUnitary</code>( <var class="Arg">x</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>A unit of a group ring is called unitary if the classical involution inverts it. This property is checked here.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsUnitary(x);
false
# let's check that elements of the group G are unitary
gap&gt; l:=List(MinimalGeneratingSet(G),g -&gt; g^Embedding(G,KG));
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
gap&gt; List(l,IsUnitary);
[ true, true ]   

</pre></td></tr></table>

<p><a id="X85CBFBAE78DE72E8" name="X85CBFBAE78DE72E8"></a></p>

<h5>4.2-10 IsUnit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsUnit</code>( <var class="Arg">[KG, ]x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>This method improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras.</p>

<p>In the two-argument version the method returns <code class="keyw">true</code> if <var class="Arg">x</var> is an invertible element of the modular group algebra <var class="Arg">KG</var> and <code class="keyw">false</code> otherwise. This can be done very quickly by checking whether the augmentation of the element <var class="Arg">x</var> is non-zero.</p>

<p>If the first argument is omitted, then <strong class="pkg">LAGUNA</strong> constructs the group H generated by the support of <var class="Arg">x</var>, and, if this group is a finite p-group, then checks whether the coefficients of <var class="Arg">x</var> belong to a field F of characteristic p. If this is the case, then <code class="code">IsUnit( FH, x )</code> is called; otherwise, standard <strong class="pkg">GAP</strong> method is used.</p>


<table class="example">
<tr><td><pre>

gap&gt; x;
(Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; IsUnit( KG, x ); # clearly, is not a unit due to augmentation zero
false
gap&gt; y := One( KG ) + x; # this should give a unit
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; IsUnit( KG, y );
true       

</pre></td></tr></table>

<p><a id="X82EC4F49877D6EB1" name="X82EC4F49877D6EB1"></a></p>

<h5>4.2-11 InverseOp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InverseOp</code>( <var class="Arg">x</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the inverse element of an element of a group ring</p>

<p>This method improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras. It calculates the inverse of a group algebra element. The user can also invoke this function by typing <code class="code"> x^-1 </code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; y;
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2
gap&gt; y^-1;
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f4+(Z(2)^0)*f1*f2+(Z(2)^
0)*f1*f3+(Z(2)^0)*f1*f4+(Z(2)^0)*f2*f4+(Z(2)^0)*f1*f2*f4+(Z(2)^0)*f2*f3*f4+(
Z(2)^0)*f1*f2*f3*f4
gap&gt; y * y^-1;
(Z(2)^0)*&lt;identity&gt; of ...    

</pre></td></tr></table>

<p><a id="X7FD01F52845445EC" name="X7FD01F52845445EC"></a></p>

<h5>4.2-12 BicyclicUnitOfType1</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BicyclicUnitOfType1</code>( <var class="Arg">[KG, ]a, g</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BicyclicUnitOfType2</code>( <var class="Arg">[KG, ]a, g</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>an element of a group ring</p>

<p>let a be an element of order n of a group G. We put alpha = 1 + a + a^2 + ... +a^n-1. Then (a-1)*g*alpha and alpha*g*(a-1) are nilpotent of index two for any element g of the group G not containing in the normalizer N_G(&lt; a &gt;), and the units u_a,g = 1 + (a-1) * g * alpha and v_a,g = 1 + alpha * g * (a-1) are called <em>bicyclic units</em> of the 1st and 2nd type respectively. Note that u_a,g and v_a,g may coincide for some a and g, but in general this does not hold. In the three-argument version these methods construct bicyclic units of both types when <var class="Arg">a</var> and <var class="Arg">g</var> are elements of the underlying group G of a group ring <var class="Arg">KG</var>. The two-argument version accepts images of elements <var class="Arg">a</var> and <var class="Arg">g</var> from the underlying group in the group ring KG obtained using the mapping <code class="code">Embedding( G, KG )</code>. Note that it is not actually checked that g is not contained in N_G(&lt; a &gt;), because this is verified in <code class="func">BicyclicUnitGroup</code> (<a href="chap4.html#X859F07AE7A4D317B"><b>4.4-13</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SmallGroup(32,6);
&lt;pc group of size 32 with 5 generators&gt;
gap&gt; KG := GroupRing( GF(2), G );
&lt;algebra-with-one over GF(2), with 5 generators&gt;
gap&gt; g := MinimalGeneratingSet( G );
[ f1, f2 ]
gap&gt; g[1] in Normalizer( G, Subgroup( G, [g[2]] ) );
false
gap&gt; g[2] in Normalizer( G, Subgroup( G, [g[1]] ) );
false
gap&gt; g := List( g, x -&gt; x^Embedding( G, KG ) );
[ (Z(2)^0)*f1, (Z(2)^0)*f2 ]
gap&gt; BicyclicUnitOfType1(g[1],g[2]) = BicyclicUnitOfType2(g[1],g[2]);
false                                                                       

</pre></td></tr></table>

<p><a id="X8631AD178508D219" name="X8631AD178508D219"></a></p>

<h5>4.2-13 BassCyclicUnit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BassCyclicUnit</code>( <var class="Arg">[ZG, ]g, k</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>an element of a group ring</p>

<p>Let <var class="Arg">g</var> be an element of order n of the group G, and 1 &lt; <var class="Arg">k</var> &lt; n be such that <var class="Arg">k</var> and n are coprime, then <var class="Arg">k</var>^Phi(n) is congruent to 1 modulo n. The unit b(g,k)= ( \sum_{j=0}^{k-1} g^j )^Phi(n) + ( (1-k^Phi(n))/n ) * Hat(g), where Hat(g) = g + g^2 + ... + g^n, is called a <em>Bass cyclic unit</em> of the integral group ring <var class="Arg">ZG</var>.</p>

<p>The three-argument version constructs the Bass cyclic unit b(g,k) for the element <var class="Arg">g</var> from the underlying group G of the group ring <var class="Arg">ZG</var>. The two-argument version accepts the image of <var class="Arg">g</var> in the group ring ZG obtained using the mapping <code class="code">Embedding( G, KG )</code>.</p>

<p>Remark that when G is a finite nilpotent group, the group generated by the Bass cyclic units contain a subgroup of finite index in the centre of the unit group of <var class="Arg">ZG</var> <a href="chapBib.html#biBJePaSe96">[JPS96]</a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; S := SymmetricGroup( 5 );;
gap&gt; ZS := GroupRing( Integers, S );;
gap&gt; f := Embedding( S, ZS );;
gap&gt; BassCyclicUnit( ZS, (1,3,2,5,4) , 3 );
(1)*()+(-2)*(1,2,4,3,5)+(-2)*(1,3,2,5,4)+(3)*(1,4,5,2,3)+(1)*(1,5,3,4,2)
gap&gt; BassCyclicUnit( (1,3,2,5,4)^f, 3 ); 
(1)*()+(-2)*(1,2,4,3,5)+(-2)*(1,3,2,5,4)+(3)*(1,4,5,2,3)+(1)*(1,5,3,4,2)

</pre></td></tr></table>

<p><a id="X841733AB86D30446" name="X841733AB86D30446"></a></p>

<h4>4.3 <span class="Heading">Important attributes of group algebras</span></h4>

<p><a id="X7F7FD75E84BEE0EF" name="X7F7FD75E84BEE0EF"></a></p>

<h5>4.3-1 AugmentationHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentationHomomorphism</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a homomorphism from a group ring to the underlying ring</p>

<p>The mapping which maps an element of a group ring KG to its augmentation is a homomorphism from KG onto the ring K; see <code class="func">Augmentation</code> (<a href="chap4.html#X86FA17BE858F2245"><b>4.2-5</b></a>). This attribute stores this homomorphism for the group ring <var class="Arg">KG</var>.</p>

<p>Please note that for calculation of the augmentation of an element of a group ring the user is strongly recommended to use <code class="func">Augmentation</code> (<a href="chap4.html#X86FA17BE858F2245"><b>4.2-5</b></a>) which works much faster than <code class="code">AugmentationHomomorphism</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; e := Embedding( G,FG );
&lt;mapping: SymmetricGroup( [ 1 .. 3 ] ) -&gt; AlgebraWithOne( GF(2), ... ) &gt;
gap&gt; x := (1,2)^e; y := (1,3)^e;
(Z(2)^0)*(1,2)
(Z(2)^0)*(1,3)
gap&gt; a := AugmentationHomomorphism( FG );
[ (Z(2)^0)*(1,2,3), (Z(2)^0)*(1,2) ] -&gt; [ Z(2)^0, Z(2)^0 ]
gap&gt; x^a; y^a; ( x + y )^a; # this is slower
Z(2)^0
Z(2)^0
0*Z(2)   
gap&gt; Augmentation(x); Augmentation(y); Augmentation( x + y ); # this is faster
Z(2)^0
Z(2)^0
0*Z(2)   

</pre></td></tr></table>

<p><a id="X7B21DB3E7CD80983" name="X7B21DB3E7CD80983"></a></p>

<h5>4.3-2 AugmentationIdeal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentationIdeal</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>an ideal of a group ring</p>

<p>If KG is a group ring, then its augmentation ideal A is generated by all elements of the form g-1, where g in G \ { 1 }. The augmentation ideal consists of all elements of FG with augmentation 0; see <code class="func">Augmentation</code> (<a href="chap4.html#X86FA17BE858F2245"><b>4.2-5</b></a>). This method changes a standard <strong class="pkg">GAP</strong> functionality for modular group algebras and returns the augmentation ideal of a modular group algebra <var class="Arg">KG</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; AugmentationIdeal( KG );
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 15)&gt;

</pre></td></tr></table>

<p><a id="X850C29907A509533" name="X850C29907A509533"></a></p>

<h5>4.3-3 RadicalOfAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RadicalOfAlgebra</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>an ideal of a group algebra</p>

<p>This method improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras of finite p-groups. Since in this case the radical of the group algebra coincides with its augmentation ideal, this method simply checks if the algebra <var class="Arg">KG</var> is a p-modular group algebra, and, if yes, it returns the augmentation ideal; otherwise, the standard <strong class="pkg">GAP</strong> method will be used.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; RadicalOfAlgebra( KG );
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 15)&gt;
gap&gt; RadicalOfAlgebra( KG ) = AugmentationIdeal( KG );
true     

</pre></td></tr></table>

<p><a id="X8292BEFC7922E773" name="X8292BEFC7922E773"></a></p>

<h5>4.3-4 WeightedBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; WeightedBasis</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a record of two components: weighted basis elements and their weights</p>

<p>The argument <var class="Arg">KG</var> must be a p-modular group algebra.</p>

<p>For a group algebra KG, let A denote the augmentation ideal, and assume that c is the smallest number such that A^c=0. Then a weighted basis of KG is some basis b_1, ..., b_n for the augmentation ideal A, for which there are indices i_1=1, ..., i_c-1 such that b_i_k, ..., b_n is a basis for A^k. The weight of an element b_i of a weighted basis is the unique integer w such that b_i belongs to w-th power of A but does not belong to its (w+1)-th power.</p>

<p>Note that this function actually constructs a basis for the <em>augmentation ideal</em> of <var class="Arg">KG</var> and not for <var class="Arg">KG</var> itself. Since the augmentation ideal has co-dimension 1 in <code class="code">KG</code>, a basis for <code class="code">KG</code> can be easily obtained by adjoining the identity element of the group.</p>

<p>The method returns a record whose basis entry is the basis and the weights entry is a list of the corresponding weights the of basis elements. See Section <a href="chap3.html#X7B74767A849D921E"><b>3.3</b></a> for more details.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), ElementaryAbelianGroup( 4 ) );
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; WeightedBasis( KG );
rec(
  weightedBasis := [ (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f2, (Z(2)^0)*&lt;identity&gt;
        of ...+(Z(2)^0)*f1, (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f1+(Z(2)^0)*f2+(
        Z(2)^0)*f1*f2 ], weights := [ 1, 1, 2 ] )

</pre></td></tr></table>

<p><a id="X84B25D3A812A8A2E" name="X84B25D3A812A8A2E"></a></p>

<h5>4.3-5 AugmentationIdealPowerSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentationIdealPowerSeries</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a list of ideals of a group algebra</p>

<p>The argument <var class="Arg">KG</var> is a p-modular group algebra. The method returns a list whose elements are the terms of the augmentation ideal filtration of <var class="Arg">KG</var>, that is <code class="code">AugmentationIdealPowerSeries(A)[i]</code> is the i-th power of the augmentation ideal of <var class="Arg">KG</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; AugmentationIdealPowerSeries( KG );
[ &lt;algebra of dimension 15 over GF(2)&gt;, &lt;algebra of dimension 13 over GF(2)&gt;,
  &lt;algebra of dimension 11 over GF(2)&gt;, &lt;algebra of dimension 9 over GF(2)&gt;,
  &lt;algebra of dimension 7 over GF(2)&gt;, &lt;algebra of dimension 5 over GF(2)&gt;,
  &lt;algebra of dimension 3 over GF(2)&gt;, &lt;algebra of dimension 1 over GF(2)&gt;,
  &lt;algebra over GF(2)&gt; ]
gap&gt; Length(last);
9      

</pre></td></tr></table>

<p><a id="X8567023A821E39A6" name="X8567023A821E39A6"></a></p>

<h5>4.3-6 AugmentationIdealNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentationIdealNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>For the p-modular group algebra <var class="Arg">KG</var> the method returns the smallest number n such that A^n=0, where A is the augmentation ideal of <var class="Arg">KG</var>. This can be done using Jenning's theory without the explicit calculations of the powers of the augmentation ideal.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; AugmentationIdealNilpotencyIndex( KG );
9      

</pre></td></tr></table>

<p><a id="X7C0D5F3C842302EC" name="X7C0D5F3C842302EC"></a></p>

<h5>4.3-7 AugmentationIdealOfDerivedSubgroupNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AugmentationIdealOfDerivedSubgroupNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>For the p-modular group algebra <var class="Arg">KG</var> this attribute stores the nilpotency index of the augmentation ideal of KG' where G' denotes the derived subgroup of G.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; AugmentationIdealOfDerivedSubgroupNilpotencyIndex( KG );
4
gap&gt; D := DerivedSubgroup( UnderlyingGroup( KG ) );
Group([ f3, f4 ])
gap&gt; KD := GroupRing( GF( 2 ), D );
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; AugmentationIdealNilpotencyIndex( KD );
4       

</pre></td></tr></table>

<p><a id="X837294D57E415E37" name="X837294D57E415E37"></a></p>

<h5>4.3-8 LeftIdealBySubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LeftIdealBySubgroup</code>( <var class="Arg">KG, H</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RightIdealBySubgroup</code>( <var class="Arg">KG, H</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TwoSidedIdalBySubgroup</code>( <var class="Arg">KG, H</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>an ideal of a group ring</p>

<p>Let <var class="Arg">KG</var> be a group ring of a group G over the ring K, and <var class="Arg">H</var> be a subgroup of G. Then the set J_l(H) of all elements of <var class="Arg">KG</var> of the form</p>

<p class="pcenter">
         \sum_{h \in H} x_h(h-1)
         </p>

<p>is the left ideal in <var class="Arg">KG</var> generated by all elements h-1 with h in H. The right ideal J_r(H) is defined analogously. These operations are used to consrtuct such ideals, taking into account the fact, that the ideal J_l(H) is two-sided if and only if <var class="Arg">H</var> is normal in G. An attempt of constructing two-sided ideal for a non-normal subgroup <var class="Arg">H</var> will lead to an error message.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF(2), DihedralGroup(16) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; G := DihedralGroup(16);
&lt;pc group of size 16 with 4 generators&gt;
gap&gt; KG := GroupRing( GF(2), G );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; D := DerivedSubgroup( G );
Group([ f3, f4 ])
gap&gt; LeftIdealBySubgroup( KG, D );
&lt;two-sided ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 12)&gt;                              
gap&gt; H := Subgroup( G, [ GeneratorsOfGroup(G)[1] ]);
Group([ f1 ])
gap&gt; IsNormal( G, H );
false
gap&gt; LeftIdealBySubgroup( KG, H );
&lt;left ideal in &lt;algebra-with-one over GF(2), with 4 generators&gt;,
  (dimension 8)&gt;

</pre></td></tr></table>

<p><a id="X863248708784F94C" name="X863248708784F94C"></a></p>

<h4>4.4 <span class="Heading">Computations with the unit group</span></h4>

<p><a id="X817D5AC78754527F" name="X817D5AC78754527F"></a></p>

<h5>4.4-1 NormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a group generated by group algebra elements</p>

<p>Determines the normalized unit group of a p-modular group algebra <var class="Arg">KG</var> over the field of p elements. Returns the normalized unit group as the group generated by certain elements of <var class="Arg">KG</var>; see Section <a href="chap3.html#X7B74767A849D921E"><b>3.3</b></a> for more details.</p>

<p>For efficient computations the user is recommended to use <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4.html#X7D40E42A7B678598"><b>4.4-2</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; V := NormalizedUnitGroup( KG );
&lt;group of size 32768 with 15 generators&gt;
gap&gt; u := GeneratorsOfGroup( V )[4];
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2  

</pre></td></tr></table>

<p><a id="X7D40E42A7B678598" name="X7D40E42A7B678598"></a></p>

<h5>4.4-2 PcNormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PcNormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a group given by power-commutator presentation</p>

<p>The argument <var class="Arg">KG</var> is a p-modular group algebra over the field of p elements. <code class="code">PcNormalizedUnitGroup</code> returns the normalized unit group of <var class="Arg">KG</var> given by a power-commutator presentation. The generators in this polycyclic presentation correspond to the weighted basis elements of <var class="Arg">KG</var>. For more details, see Section <a href="chap3.html#X7B74767A849D921E"><b>3.3</b></a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; W := PcNormalizedUnitGroup( KG );
&lt;pc group of size 32768 with 15 generators&gt;
gap&gt; w := GeneratorsOfGroup( W )[4];
f4       

</pre></td></tr></table>

<p><a id="X7E08F6E87C586A36" name="X7E08F6E87C586A36"></a></p>

<h5>4.4-3 NaturalBijectionToPcNormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NaturalBijectionToPcNormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a homomorphism of groups</p>

<p>The normalised unit group of a p-modular group algebra KG over the field of p elements can be computed using two methods, namely <code class="func">NormalizedUnitGroup</code> (<a href="chap4.html#X817D5AC78754527F"><b>4.4-1</b></a>) and <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4.html#X7D40E42A7B678598"><b>4.4-2</b></a>). These two methods return two different objects, and they can be used for different types of computations. The elements of <code class="code">NormalizedUnitGroup(KG)</code> are represented in their natural group algebra representation, and hence they can easily be identified in the group algebra. However, the more quickly constructed <code class="code">NormalizedUnitGroup(KG)</code> is often not suitable for further fast calculations. Hence one will have to use <code class="code">PcNormalizedUnitGroup(KG)</code> if one wants to find some group theoretic properties of the normalized unit group. This method returns the bijection from <code class="code">NormalizedUnitGroup(<var class="Arg">KG</var>)</code> onto <code class="code">PcNormalizedUnitGroup(<var class="Arg">KG</var>)</code>. This bijection can be used to map the result of a computation in <code class="code">PcNormalizedUnitGroup(<var class="Arg">KG</var>)</code> into <code class="code">NormalizedUnitGroup(<var class="Arg">KG</var>)</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; f := NaturalBijectionToPcNormalizedUnitGroup( KG );
MappingByFunction( &lt;group of size 32768 with
15 generators&gt;, &lt;pc group of size 32768 with
15 generators&gt;, function( x ) ... end )
gap&gt; u := GeneratorsOfGroup( V )[4];;
gap&gt; u^f;
f4   
gap&gt; GeneratorsOfGroup( V )[4]^f = GeneratorsOfGroup( W )[4];
true      

</pre></td></tr></table>

<p><a id="X83715EF37B9FA94A" name="X83715EF37B9FA94A"></a></p>

<h5>4.4-4 NaturalBijectionToNormalizedUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NaturalBijectionToNormalizedUnitGroup</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a homomorphism of groups</p>

<p>For a p-modular group algebra <var class="Arg">KG</var> over the field of p elements this function returns the inverse of the mapping <code class="func">NaturalBijectionToPcNormalizedUnitGroup</code> (<a href="chap4.html#X7E08F6E87C586A36"><b>4.4-3</b></a>)</p>


<table class="example">
<tr><td><pre>

gap&gt; t := NaturalBijectionToNormalizedUnitGroup(KG);;
gap&gt; w := GeneratorsOfGroup(W)[4];;
gap&gt; w^t;
(Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f1*f2    
gap&gt; GeneratorsOfGroup( W )[4]^t = GeneratorsOfGroup( V )[4];
true     

</pre></td></tr></table>

<p><a id="X84D64AF17941FA7F" name="X84D64AF17941FA7F"></a></p>

<h5>4.4-5 Embedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Embedding</code>( <var class="Arg">H, V</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a homomorphism from an underlying group to a normalized unit group in pc-presentation</p>

<p>Let <var class="Arg">H</var> be a subgroup of a group G and <var class="Arg">V</var> be the normalized unit group of the group algebra KG given by the power-commutator presentation (see <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4.html#X7D40E42A7B678598"><b>4.4-2</b></a>). Then <code class="code">Embedding( H, V )</code> returns the homomorphism from <var class="Arg">H</var> to <var class="Arg">V</var>, which is the composition of <code class="code">Embedding( H, KG )</code> and <code class="code">NaturalBijectionToPcNormalizedUnitGroup( KG )</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := DihedralGroup( 16 );
&lt;pc group of size 16 with 4 generators&gt;
gap&gt; KG := GroupRing( GF( 2 ), G );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; V:=PcNormalizedUnitGroup( KG );
&lt;pc group of size 32768 with 15 generators&gt;
gap&gt; ucs := UpperCentralSeries( V );
[ &lt;pc group of size 32768 with 15 generators&gt;,
  &lt;pc group of size 4096 with 12 generators&gt;,
  Group([ f3*f5*f13*f15, f7, f15, f13*f15, f14*f15, f11*f13*f14*f15, f12,
      f9*f12, f10 ]),
  Group([ f3*f5*f13*f15, f7, f15, f13*f15, f14*f15, f11*f13*f14*f15 ]),
  Group([  ]) ]
gap&gt; f := Embedding( G, V );
[ f1, f2, f3, f4 ] -&gt; [ f2, f1, f3, f7 ]
gap&gt; G1 := Image( f, G ); 
Group([ f2, f1, f3, f7 ])
gap&gt; H := Intersection( ucs[2], G1 ); 
Group([ f3, f7, f3*f7 ])
# H is the intersection of G and the 3rd centre of V(KG)
gap&gt; T:=PreImage( f, H );
Group([ f3, f4, f3*f4 ])
# and T is its preimage in G
gap&gt; IdGroup( T ); 
[ 4, 1 ]

</pre></td></tr></table>

<p><a id="X853C045B7BA6A580" name="X853C045B7BA6A580"></a></p>

<h5>4.4-6 Units</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Units</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the unit group of a group ring</p>

<p>This improves a standard <strong class="pkg">GAP</strong> functionality for modular group algebras of finite p-groups over the field of p elements. It returns the unit group of <var class="Arg">KG</var> as a direct product of <code class="code">Units(K)</code> and <code class="code">NormalizedUnitGroup(KG)</code>, where the latter is generated by certain elements of <var class="Arg">KG</var>; see Chapter <a href="chap3.html#X7D9FCE3A8526ACBE"><b>3</b></a> for more details.</p>


<table class="example">
<tr><td><pre>

gap&gt; U := Units( KG );
#I  LAGUNA package: Computing the unit group ...
&lt;group of size 32768 with 15 generators&gt;
# now elements of U are already in KG
gap&gt; GeneratorsOfGroup( U )[5];
(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f2*f3 
# in the next example the direct product structure is more clear 
gap&gt; FH := GroupRing( GF(3), SmallGroup(27,3) );
&lt;algebra-with-one over GF(3), with 3 generators&gt;
gap&gt; T := Units( FH );
#I  LAGUNA package: Computing the unit group ...
&lt;group of size 5083731656658 with 27 generators&gt;
gap&gt; x := GeneratorsOfGroup( T )[1];
Tuple( [ Z(3), (Z(3)^0)*&lt;identity&gt; of ... ] ) 
gap&gt; x in FH;
false
gap&gt; x[1] * x[2] in FH; 
true # this is the way to get the corresponding element of FH

</pre></td></tr></table>

<p><a id="X7E67BDA77E5E6077" name="X7E67BDA77E5E6077"></a></p>

<h5>4.4-7 PcUnits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; PcUnits</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a group given by power-commutator presentation</p>

<p>Returns the unit group of <var class="Arg">KG</var> as a direct product of <code class="code">Units(K)</code> and <code class="code">PcNormalizedUnitGroup(KG)</code>, where the latter is a group given by a polycyclic presentation. See Section <a href="chap3.html#X7DCB12F48752C17E"><b>3.4</b></a> for more details.</p>


<table class="example">
<tr><td><pre>

gap&gt; W := PcUnits( KG );
&lt;pc group of size 32768 with 15 generators&gt;
gap&gt; GeneratorsOfGroup( W )[5];
f5   
# in the next example the direct product structure is more clear 
gap&gt; FH := GroupRing( GF(3), SmallGroup(27,3) );
&lt;algebra-with-one over GF(3), with 3 generators&gt;
gap&gt; T := PcUnits(FH);
&lt;group of size 5083731656658 with 27 generators&gt;
gap&gt; x := GeneratorsOfGroup( T )[2];
Tuple( [ Z(3)^0, f1 ] )                       

</pre></td></tr></table>

<p><a id="X7F2532888184CB22" name="X7F2532888184CB22"></a></p>

<h5>4.4-8 IsGroupOfUnitsOfMagmaRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsGroupOfUnitsOfMagmaRing</code>( <var class="Arg">U</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>This property will be automatically set <code class="keyw">true</code>, if <var class="Arg">U</var> is a group generated by some units of a magma ring, including <code class="code">Units(KG)</code> and <code class="code">NormalizedUnitgroup(KG)</code>. Otherwise this property will not be bound.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsGroupOfUnitsOfMagmaRing( NormalizedUnitGroup( KG ) );
true
gap&gt; IsGroupOfUnitsOfMagmaRing( Units( KG ) );
true     

</pre></td></tr></table>

<p><a id="X7EF9BF297A9412AB" name="X7EF9BF297A9412AB"></a></p>

<h5>4.4-9 IsUnitGroupOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsUnitGroupOfGroupRing</code>( <var class="Arg">U</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>This property will be automatically set <code class="keyw">true</code>, if <var class="Arg">U</var> is the unit group of a p-modular group algebra, obtained either by <code class="code">Units(KG)</code> or by <code class="code">PcUnits(KG)</code>. Otherwise this property will not be bound.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsUnitGroupOfGroupRing( Units( KG ) );
true
gap&gt; IsUnitGroupOfGroupRing( PcUnits( KG ) );
true     

</pre></td></tr></table>

<p><a id="X82AC131384191CCE" name="X82AC131384191CCE"></a></p>

<h5>4.4-10 IsNormalizedUnitGroupOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsNormalizedUnitGroupOfGroupRing</code>( <var class="Arg">U</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>This property will be automatically set <code class="keyw">true</code>, if <var class="Arg">U</var> is the normalized unit group of a p-modular group algebra, obtained either by <code class="code">NormalizedUnitGroup(KG)</code> or by <code class="code">PcNormalizedUnitGroup(KG)</code>. Otherwise this property will not be bound.</p>


<table class="example">
<tr><td><pre>

gap&gt; IsNormalizedUnitGroupOfGroupRing( NormalizedUnitGroup( KG ) );
true
gap&gt; IsNormalizedUnitGroupOfGroupRing( PcNormalizedUnitGroup( KG ) );
true     

</pre></td></tr></table>

<p><a id="X82DCA8A57D0D1114" name="X82DCA8A57D0D1114"></a></p>

<h5>4.4-11 UnderlyingGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingGroupRing</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a group ring</p>

<p>If <var class="Arg">U</var> is the (normalized) unit group of a p-modular group algebra KG obtained using one of the functions <code class="code">Units(KG)</code>, <code class="code">PcUnits(KG)</code>, <code class="code">NormalizedUnitGroup(KG)</code> or <code class="code">PcNormalizedUnitGroup(KG)</code>, then the attribute <code class="code">UnderlyingGroupRing</code> stores KG.</p>


<table class="example">
<tr><td><pre>

gap&gt; UnderlyingGroupRing( Units( KG ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; UnderlyingGroupRing( PcUnits( KG ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; UnderlyingGroupRing( NormalizedUnitGroup( KG ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; UnderlyingGroupRing( PcNormalizedUnitGroup( KG ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;

</pre></td></tr></table>

<p><a id="X7A0FFABC86F89517" name="X7A0FFABC86F89517"></a></p>

<h5>4.4-12 UnitarySubgroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnitarySubgroup</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the subgroup of the unit group</p>

<p>Let <var class="Arg">U</var> be the normalized unit group of a group ring in either natural (see <code class="func">NormalizedUnitGroup</code> (<a href="chap4.html#X817D5AC78754527F"><b>4.4-1</b></a>)) or power-commutator (see <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4.html#X7D40E42A7B678598"><b>4.4-2</b></a>)) presentation. The attribute stores the unitary subgroup of <var class="Arg">U</var>, generated by all unitary units of <var class="Arg">U</var> (see <code class="func">IsUnitary</code> (<a href="chap4.html#X7990BD877E89A9EC"><b>4.2-9</b></a>)). The method is straightforward, so it is not recommended to run it for large groups.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 8 ) );
&lt;algebra-with-one over GF(2), with 3 generators&gt;
gap&gt; U := NormalizedUnitGroup( KG );
&lt;group of size 128 with 7 generators&gt;
gap&gt; HU := UnitarySubgroup( U );
&lt;group with 5 generators&gt;
gap&gt; IdGroup( HU );
[ 64, 261 ]
gap&gt; V := PcNormalizedUnitGroup( KG );
&lt;pc group of size 128 with 7 generators&gt;
gap&gt; HV := UnitarySubgroup( V );
Group([ f1, f2, f5, f6, f7 ])
gap&gt; IdGroup( HV );
[ 64, 261 ]
gap&gt; Image(NaturalBijectionToPcNormalizedUnitGroup( KG ), HU ) = HV;
true

</pre></td></tr></table>

<p><a id="X859F07AE7A4D317B" name="X859F07AE7A4D317B"></a></p>

<h5>4.4-13 BicyclicUnitGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; BicyclicUnitGroup</code>( <var class="Arg">U</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the subgroup of the unit group, generated by bicyclic units</p>

<p>Let <var class="Arg">U</var> be the normalized unit group of a group ring in either natural (see <code class="func">NormalizedUnitGroup</code> (<a href="chap4.html#X817D5AC78754527F"><b>4.4-1</b></a>)) or power-commutator (see <code class="func">PcNormalizedUnitGroup</code> (<a href="chap4.html#X7D40E42A7B678598"><b>4.4-2</b></a>)) presentation. The attribute stores the subgroup of <var class="Arg">U</var>, generated by all bicyclic units u_g,h and v_g,h (see <code class="func">BicyclicUnitOfType1</code> (<a href="chap4.html#X7FD01F52845445EC"><b>4.2-12</b></a>) and <code class="func">BicyclicUnitOfType1</code> (<a href="chap4.html#X7FD01F52845445EC"><b>4.2-12</b></a>)), where g and h run over the elements of the underlying group, and h do not belongs to the normalizer of &lt; g &gt; in G.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 8 ) );
&lt;algebra-with-one over GF(2), with 3 generators&gt;
gap&gt; U := NormalizedUnitGroup( KG );
&lt;group of size 128 with 7 generators&gt;
gap&gt; BU := BicyclicUnitGroup( U );
&lt;group with 2 generators&gt;
gap&gt; IdGroup( BU );
[ 4, 2 ]
gap&gt; V := PcNormalizedUnitGroup( KG );
&lt;pc group of size 128 with 7 generators&gt;
gap&gt; BV := BicyclicUnitGroup( V );
Group([ f5*f6, f6*f7 ])
gap&gt; IdGroup( BV );
[ 4, 2 ]
gap&gt; Image( NaturalBijectionToPcNormalizedUnitGroup( KG ), BU ) = BV;
true

</pre></td></tr></table>

<p><a id="X7A39E44D87CDF7B0" name="X7A39E44D87CDF7B0"></a></p>

<h5>4.4-14 GroupBases</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; GroupBases</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a list of lists of group rings elements</p>

<p>The subgroup B of the normalized unit group of the group algebra KG is called a <em>group basis</em>, if the elements of B are linearly independent over the field K and KB=KG. If <var class="Arg">KG</var> is a p-modular group algebra, then <code class="code">GroupBases</code> returns a list of representatives of the conjugacy classes of the group bases of the group algebra <var class="Arg">KG</var> in its normalised unit group.</p>


<table class="example">
<tr><td><pre>

gap&gt; D8 := DihedralGroup( 8 );
&lt;pc group of size 8 with 3 generators&gt;
gap&gt; K := GF(2);
GF(2)
gap&gt; KD8 := GroupRing( GF( 2 ), D8 );
&lt;algebra-with-one over GF(2), with 3 generators&gt;
gap&gt; gb := GroupBases( KD8 );;
gap&gt; Length( gb );
32
gap&gt; gb[1];
[ (Z(2)^0)*&lt;identity&gt; of ..., (Z(2)^0)*f3,
  (Z(2)^0)*f1*f2+(Z(2)^0)*f2*f3+(Z(2)^0)*f1*f2*f3,
  (Z(2)^0)*f2+(Z(2)^0)*f1*f2+(Z(2)^0)*f1*f2*f3,
  (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f2*f3+(Z(2)^
    0)*f1*f2*f3, (Z(2)^0)*f2+(Z(2)^0)*f1*f3+(Z(2)^0)*f2*f3,
  (Z(2)^0)*&lt;identity&gt; of ...+(Z(2)^0)*f2+(Z(2)^0)*f3+(Z(2)^0)*f1*f2+(Z(2)^
    0)*f2*f3, (Z(2)^0)*f1+(Z(2)^0)*f2+(Z(2)^0)*f2*f3 ]
gap&gt; Length( last );
8    

</pre></td></tr></table>

<p><a id="X783C1A3D86A6656B" name="X783C1A3D86A6656B"></a></p>

<h4>4.5 <span class="Heading">The Lie algebra of a group algebra</span></h4>

<p><a id="X7827B4158459DEA0" name="X7827B4158459DEA0"></a></p>

<h5>4.5-1 LieAlgebraByDomain</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieAlgebraByDomain</code>( <var class="Arg">A</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>This method takes a group algebra as its argument, and constructs its associated Lie algebra in which the product is the bracket operation: [a,b]=ab-ba. It is recommended that the user never calls this method. The Lie algebra for an associative algebra should normally be created using <code class="code">LieAlgebra( A )</code>. When <code class="code">LieAlgebra</code> is first invoked, it constructs the Lie algebra for <var class="Arg">A</var> using <code class="code">LieAlgebraByDomain</code>. After that it stores this Lie algebra and simply returns it if <code class="code">LieAlgebra</code> is called again.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SymmetricGroup(3);; FG := GroupRing( GF( 2 ), G );
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;

</pre></td></tr></table>

<p><a id="X7AA7DA6082639B23" name="X7AA7DA6082639B23"></a></p>

<h5>4.5-2 IsLieAlgebraByAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieAlgebraByAssociativeAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">( category )</td></tr></table></div>
<p>This category signifies that the Lie algebra <var class="Arg">L</var> was constructed as the Lie algebra associated with an associative algebra (this piece of information cannot be obtained later).</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF(3), DihedralGroup(16) );
&lt;algebra-with-one over GF(3), with 4 generators&gt;
gap&gt; L := LieAlgebra ( KG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(3)&gt;
gap&gt; IsLieAlgebraByAssociativeAlgebra( L );
true

</pre></td></tr></table>

<p><a id="X85F4712B84624DB8" name="X85F4712B84624DB8"></a></p>

<h5>4.5-3 UnderlyingAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingAssociativeAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the underlying associative algebra of a Lie algebra</p>

<p>If a Lie algebra <var class="Arg">L</var> is constructed from an associative algebra, then it remembers this underlying associative algebra as one of its attributes.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF(2), DihedralGroup(16) ); 
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; L := LieAlgebra ( KG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; UnderlyingAssociativeAlgebra( L );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; last = KG;
true  

</pre></td></tr></table>

<p><a id="X84050A268514F2EE" name="X84050A268514F2EE"></a></p>

<h5>4.5-4 NaturalBijectionToLieAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NaturalBijectionToLieAlgebra</code>( <var class="Arg">A</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>a mapping</p>

<p>The natural linear bijection between the (isomorphic, but not equal) underlying vector spaces of an associative algebra <var class="Arg">A</var> and its associated Lie algebra is stored as an attribute of <var class="Arg">A</var>. Note that this is a vector space isomorphism between two algebras, but not an algebra isomorphism.</p>


<table class="example">
<tr><td><pre>

gap&gt; F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; t := NaturalBijectionToLieAlgebra( FG ); 
MappingByFunction( &lt;algebra-with-one over GF(2), with 
2 generators&gt;, &lt;Lie algebra over GF(
2)&gt;, &lt;Operation "LieObject"&gt;, function( y ) ... end )
gap&gt; a := Random( FG );
(Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3)
gap&gt; a * a;                     # product in the associative algebra
(Z(2)^0)*()+(Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2)
gap&gt; b := a^t;
LieObject( (Z(2)^0)*(1,2,3)+(Z(2)^0)*(1,3,2)+(Z(2)^0)*(1,3) )
gap&gt; b * b;                     # product in the Lie algebra (commutator) ...
LieObject( &lt;zero&gt; of ... )      # ... must be zero!   

</pre></td></tr></table>

<p><a id="X821DAFD585EA1DF3" name="X821DAFD585EA1DF3"></a></p>

<h5>4.5-5 NaturalBijectionToAssociativeAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; NaturalBijectionToAssociativeAlgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This is the inverse of the previous linear bijection, stored as an attribute of the Lie algebra <var class="Arg">L</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SymmetricGroup(3); FG := GroupRing( GF( 2 ), G );
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; s := NaturalBijectionToAssociativeAlgebra( L );
MappingByFunction( &lt;Lie algebra over GF(2)&gt;, &lt;algebra-with-one over GF(
2), with 2 generators&gt;, function( y ) ... end, &lt;Operation "LieObject"&gt; )
gap&gt; InverseGeneralMapping( s ) = NaturalBijectionToLieAlgebra( FG );
true   

</pre></td></tr></table>

<p><a id="X78C26E3F80E55AC2" name="X78C26E3F80E55AC2"></a></p>

<h5>4.5-6 IsLieAlgebraOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieAlgebraOfGroupRing</code>( <var class="Arg">L</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>If a Lie algebra <var class="Arg">L</var> is constructed from an associative algebra which happens to be in fact a group ring, it has many nice properties that can be used for fast algorithms, so this information is stored as a property.</p>


<table class="example">
<tr><td><pre>

gap&gt; F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; IsLieAlgebraOfGroupRing( L );
true   

</pre></td></tr></table>

<p><a id="X87CCD17A790BE256" name="X87CCD17A790BE256"></a></p>

<h5>4.5-7 UnderlyingGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; UnderlyingGroup</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>the underlying group</p>

<p>The underlying group of a Lie algebra <var class="Arg">L</var> that is constructed from a group ring is defined as the underlying group of this group ring; see <code class="func">UnderlyingGroup</code> (<a href="chap4.html#X7C966B177BB62C72"><b>4.1-4</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; UnderlyingGroup( L );
Sym( [ 1 .. 3 ] )
gap&gt; LeftActingDomain( L );
GF(2)   

</pre></td></tr></table>

<p><a id="X833439F7846784B5" name="X833439F7846784B5"></a></p>

<h5>4.5-8 Embedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Embedding</code>( <var class="Arg">U, L</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a mapping, which is a composition of two mappings</p>

<p>Let FG be a group ring, let <var class="Arg">U</var> be a submagma of G, and let <var class="Arg">L</var> be the Lie algebra associated with FG. Then <code class="code">Embedding(<var class="Arg">U</var>, <var class="Arg">L</var> )</code> returns the obvious mapping from <var class="Arg">U</var> to <var class="Arg">L</var> (as the composition of the mappings <code class="code">Embedding( <var class="Arg">U</var>, FG )</code> and <code class="code">NaturalBijectionToLieAlgebra( FG )</code>).</p>


<table class="example">
<tr><td><pre>

gap&gt; F := GF( 2 ); G := SymmetricGroup( 3 ); FG := GroupRing( F, G );
GF(2)
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; f := Embedding( G, L );
CompositionMapping( MappingByFunction( &lt;algebra-with-one over GF(2), with 
2 generators&gt;, &lt;Lie algebra over GF(
2)&gt;, &lt;Operation "LieObject"&gt;, function( y ) ... end ), &lt;mapping: SymmetricGrou\
p( [ 1 .. 3 ] ) -&gt; AlgebraWithOne( GF(2), ... ) &gt; )
gap&gt; (1,2)^f + (1,3)^f;
LieObject( (Z(2)^0)*(1,2)+(Z(2)^0)*(1,3) )   

</pre></td></tr></table>

<p><a id="X8111F58E7DE3E25C" name="X8111F58E7DE3E25C"></a></p>

<h5>4.5-9 LieCentre</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieCentre</code>( <var class="Arg">L</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a Lie algebra</p>

<p>The centre of the Lie algebra associated with a group ring corresponds to the centre of the underlying group ring, and it can be calculated very fast by considering the conjugacy classes of the group. This method returns the centre of <var class="Arg">L</var> using this idea.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); 
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; C := LieCentre( L );
&lt;Lie algebra of dimension 28 over GF(2)&gt;
gap&gt; D := LieDerivedSubalgebra( L );
#I  LAGUNA package: Computing the Lie derived subalgebra ...
&lt;Lie algebra of dimension 228 over GF(2)&gt;
gap&gt; c := Dimension( C ); d := Dimension( D ); l := Dimension( L );
28
228
256
gap&gt; c + d = l;
true  # This is always the case for Lie algebras of group algebras!   

</pre></td></tr></table>

<p><a id="X7C95C0057C977747" name="X7C95C0057C977747"></a></p>

<h5>4.5-10 LieDerivedSubalgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieDerivedSubalgebra</code>( <var class="Arg">L</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>a Lie algebra</p>

<p>If <var class="Arg">L</var> is the Lie algebra associated with a group ring, then this method returns the Lie derived subalgebra of <var class="Arg">L</var>. This can be done very fast using the conjugacy classes of the underlying group.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); 
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; C := LieCentre( L );
&lt;Lie algebra of dimension 28 over GF(2)&gt;
gap&gt; D := LieDerivedSubalgebra( L );
#I  LAGUNA package: Computing the Lie derived subalgebra ...    
&lt;Lie algebra of dimension 228 over GF(2)&gt;
gap&gt; l := Dimension( L ); c := Dimension( C ); d := Dimension( D );
256
28
228
gap&gt; c + d = l;
true  # This is always the case for Lie algebras of group algebras!   

</pre></td></tr></table>

<p><a id="X7F97D08F7B738ADE" name="X7F97D08F7B738ADE"></a></p>

<h5>4.5-11 IsLieAbelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieAbelian</code>( <var class="Arg">L</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>The Lie algebra <var class="Arg">L</var> of an associative algebra A is Lie abelian, if and only if A is abelian, so this method refers to <code class="code">IsAbelian( A )</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G); 
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );          
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; IsAbelian( G );
false
gap&gt; IsAbelian( L );    # This command should never be used for Lie algebras!
true                    # It gives a result, but (probably) not the desired one.
gap&gt; IsLieAbelian( L ); # Instead, IsLieAbelian is the correct command.
false   

</pre></td></tr></table>

<p><a id="X859FF1B3812B8FCC" name="X859FF1B3812B8FCC"></a></p>

<h5>4.5-12 IsLieSolvable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieSolvable</code>( <var class="Arg">L</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>In <a href="chapBib.html#biBPPS73">[PPS73]</a> Passi, Passman, and Sehgal have classified all groups G such that the Lie algebra associated with the group ring is solvable. This method uses their classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); 
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; IsLieSolvable( L );                       # This is very fast.
true
gap&gt; List( LieDerivedSeries( L ), Dimension ); # This is very slow.
[ 256, 228, 189, 71, 0 ]   

</pre></td></tr></table>

<p><a id="X78452F4E875A62A8" name="X78452F4E875A62A8"></a></p>

<h5>4.5-13 IsLieNilpotent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieNilpotent</code>( <var class="Arg">L</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>In <a href="chapBib.html#biBPPS73">[PPS73]</a> Passi, Passman, and Sehgal have classified all groups G such that the Lie algebra associated with the group ring is Lie nilpotent. This method uses their classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); 
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; IsLieNilpotent( L );                           # This is very fast.
true
gap&gt; List( LieLowerCentralSeries( L ), Dimension ); # This is very slow.
[ 256, 228, 222, 210, 191, 167, 138, 107, 76, 54, 29, 15, 6, 0 ]   

</pre></td></tr></table>

<p><a id="X8504EC257B764BA6" name="X8504EC257B764BA6"></a></p>

<h5>4.5-14 IsLieMetabelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieMetabelian</code>( <var class="Arg">L</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>In <a href="chapBib.html#biBLR86">[LR86]</a> Levin and Rosenberger have classified all groups G such that the Lie algebra associated with the group ring is Lie metabelian. This method uses their classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SmallGroup( 256, 400 ); FG := GroupRing( GF( 2 ), G ); 
&lt;pc group of size 256 with 8 generators&gt;
&lt;algebra-with-one over GF(2), with 8 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; IsLieMetabelian( L );
false   

</pre></td></tr></table>

<p><a id="X7EEAA09F818CE548" name="X7EEAA09F818CE548"></a></p>

<h5>4.5-15 IsLieCentreByMetabelian</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsLieCentreByMetabelian</code>( <var class="Arg">L</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>In <a href="chapBib.html#biBRoss">[Ros02]</a> the third author of this package classified all groups G such that the Lie algebra associated with the group ring is Lie centre-by-metabelian. This method uses the classification, making it considerably faster than the more elementary method which just calculates Lie commutators.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); 
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );       
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; IsLieMetabelian( L );                                             
false
gap&gt; IsLieCentreByMetabelian( L );
true   

</pre></td></tr></table>

<p><a id="X7C8EBFF5805F8C51" name="X7C8EBFF5805F8C51"></a></p>

<h5>4.5-16 CanonicalBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CanonicalBasis</code>( <var class="Arg">L</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>basis of a Lie algebra</p>

<p>The canonical basis of a group algebra FG is formed by the elements of G. Here <var class="Arg">L</var> is the Lie algebra associated with FG, and the method returns the images of the elements of G in <var class="Arg">L</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); 
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );       
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; B := CanonicalBasis( L );
CanonicalBasis( &lt;Lie algebra of dimension 6 over GF(2)&gt; )
gap&gt; Elements( B );
[ LieObject( (Z(2)^0)*() ), LieObject( (Z(2)^0)*(2,3) ),
  LieObject( (Z(2)^0)*(1,2) ), LieObject( (Z(2)^0)*(1,2,3) ),
  LieObject( (Z(2)^0)*(1,3,2) ), LieObject( (Z(2)^0)*(1,3) ) ]

</pre></td></tr></table>

<p><a id="X83026DFF8461B96D" name="X83026DFF8461B96D"></a></p>

<h5>4.5-17 IsBasisOfLieAlgebraOfGroupRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsBasisOfLieAlgebraOfGroupRing</code>( <var class="Arg">B</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>A basis <var class="Arg">B</var> has this property if the preimages of the basis vectors in the group algebra form a group. It can be verified if a basis has this property. This is important for the speed of the calculation of the structure constants table; see <code class="func">StructureConstantsTable</code> (<a href="chap4.html#X804ADF0280F67CDC"><b>4.5-18</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; G := SymmetricGroup( 3 ); FG := GroupRing( GF( 2 ), G ); 
Sym( [ 1 .. 3 ] )
&lt;algebra-with-one over GF(2), with 2 generators&gt;
gap&gt; L := LieAlgebra( FG );    
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; B := CanonicalBasis( L );
CanonicalBasis( &lt;Lie algebra of dimension 6 over GF(2)&gt; )
gap&gt; IsBasisOfLieAlgebraOfGroupRing( B );
true   

</pre></td></tr></table>

<p><a id="X804ADF0280F67CDC" name="X804ADF0280F67CDC"></a></p>

<h5>4.5-18 StructureConstantsTable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; StructureConstantsTable</code>( <var class="Arg">B</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>A very fast implementation for calculating the structure constants table for the Lie algebra <code class="code">L</code> associated with a group ring with respect to its canonical basis <var class="Arg">B</var> using its special structure; see <code class="func">CanonicalBasis</code> (<a href="chap4.html#X7C8EBFF5805F8C51"><b>4.5-16</b></a>).</p>


<table class="example">
<tr><td><pre>

gap&gt; G := CyclicGroup( 2 ); FG := GroupRing( GF( 2 ), G ); 
&lt;pc group of size 2 with 1 generators&gt;
&lt;algebra-with-one over GF(2), with 1 generators&gt;
gap&gt; L := LieAlgebra( FG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; B := CanonicalBasis( L );
CanonicalBasis( &lt;Lie algebra of dimension 2 over GF(2)&gt; )
gap&gt; StructureConstantsTable( B );       
[ [ [ [  ], [  ] ], [ [  ], [  ] ] ], [ [ [  ], [  ] ], [ [  ], [  ] ] ], -1, 
  0*Z(2) ]  

</pre></td></tr></table>

<p><a id="X87E9411284D1A346" name="X87E9411284D1A346"></a></p>

<h5>4.5-19 LieUpperNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieUpperNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>In a modular group algebra KG the <em>upper Lie power series</em> is defined as follows: KG^(1)=KG, KG^(n+1) is the associative ideal, generated by [KG^(n),KG]. The upper Lie nilpotency index t^L(G) of the group algebra KG is defined to be the smallest number n such that KG^(n)=0. It can be calculated very fast using Lie dimension subgroups <a href="chapBib.html#biBShalev91">[Sha91]</a>, that is, using only information about the underlying group; see <code class="func">LieDimensionSubgroups</code> (<a href="chap4.html#X84B7C6A38473722F"><b>4.6-4</b></a>). This is why it is stored as an attribute of the group algebra <var class="Arg">KG</var> rather than that of its associated Lie algebra.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; LieUpperNilpotencyIndex( KG );
5      

</pre></td></tr></table>

<p><a id="X7D71DF0579FBE1C9" name="X7D71DF0579FBE1C9"></a></p>

<h5>4.5-20 LieLowerNilpotencyIndex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieLowerNilpotencyIndex</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>In a modular group algebra KG the <em>lower Lie power series</em> is defined as follows: KG^[n] is the associative ideal, generated by all (left-normed) Lie-products [x_1, x_2, dots, x_n], x_i in KG. The lower Lie nilpotency index t_L(G) of the group algebra KG is defined to be the minimal smallest n such that KG^[n]=0. In <a href="chapBib.html#biBDu">[Du92]</a> the Jennings' conjecture was proved, which means that the nilpotency class of the normalized unit group of the modular group algebra KG is equal to t_L(G)-1.</p>

<p>This allows to express lower Lie nilpotency index via the nilpotency class of the normalized unit group, and with its polycyclic presentation, provided by <strong class="pkg">LAGUNA</strong>, this will be faster than elementary calculations with Lie commutators. As the previous attribute, this index is also stored as an attribute of the group algebra <var class="Arg">KG</var>.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF( 2 ), DihedralGroup( 16 ) );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; LieLowerNilpotencyIndex( KG );
5     

</pre></td></tr></table>

<p><a id="X7E5950517F0CDB47" name="X7E5950517F0CDB47"></a></p>

<h5>4.5-21 LieDerivedLength</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieDerivedLength</code>( <var class="Arg">L</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Let L be a Lie algebra. The <em>Lie derived series</em> of L is defined as follows: delta^[0](L) = L and delta^[n](L) = [delta^[n-1](L), delta^[n-1](L)]. L is called Lie solvable if there exists an integer m such that delta^[m](L) = 0. In this case the integer m is called the <em>Lie derived length</em> of L, and it is returned by this function.</p>


<table class="example">
<tr><td><pre>

gap&gt; KG := GroupRing( GF ( 2 ), DihedralGroup( 16 ) );;
gap&gt; L := LieAlgebra( KG );
#I  LAGUNA package: Constructing Lie algebra ...
&lt;Lie algebra over GF(2)&gt;
gap&gt; LieDerivedLength( L );
#I  LAGUNA package: Computing the Lie derived subalgebra ...
3                                                            

</pre></td></tr></table>

<p><a id="X7B16423A7FBED034" name="X7B16423A7FBED034"></a></p>

<h4>4.6 <span class="Heading">Other commands</span></h4>

<p><a id="X85CE6B407910F768" name="X85CE6B407910F768"></a></p>

<h5>4.6-1 SubgroupsOfIndexTwo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SubgroupsOfIndexTwo</code>( <var class="Arg">G</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns a list of subgroups of G with index two. Such subgroups are important for the investigation of the Lie structure of the group algebra KG in the case of characteristic 2.</p>


<table class="example">
<tr><td><pre>

gap&gt; SubgroupsOfIndexTwo( DihedralGroup( 16) );
[ Group([ f1, f1*f3, f1*f4, f1*f3*f4 ]), Group([ f2, f2*f3, f2*f4, f2*f3*f4 ]),
  Group([ f1*f2, f1*f2*f3, f1*f2*f4, f1*f2*f3*f4 ]) ]     

</pre></td></tr></table>

<p><a id="X7AFBD42180787A07" name="X7AFBD42180787A07"></a></p>

<h5>4.6-2 DihedralDepth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DihedralDepth</code>( <var class="Arg">U</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p>For a finite 2-group <var class="Arg">U</var>, the function returns its <em>dihedral depth</em>, which is defined to be the maximal number d such that <var class="Arg">U</var> contains a subgroup isomorphic to the dihedral group of order 2^d+1.</p>


<table class="example">
<tr><td><pre>

gap&gt; KD8 := GroupRing( GF(2), DihedralGroup( 8 ) );
&lt;algebra-with-one over GF(2), with 3 generators&gt;
gap&gt; UD8 := PcNormalizedUnitGroup( KD8 );
&lt;pc group of size 128 with 7 generators&gt;
gap&gt; DihedralDepth( UD8 );
2      

</pre></td></tr></table>

<p><a id="X7D7CD02F803FFC08" name="X7D7CD02F803FFC08"></a></p>

<h5>4.6-3 DimensionBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; DimensionBasis</code>( <var class="Arg">G</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>record with two components: `dimensionBasis' (list of group elements) and `weights' (list of weights)</p>

<p>For a finite p-group <var class="Arg">G</var>, returns its Jennings basis as it was described in Section <a href="chap3.html#X7B74767A849D921E"><b>3.3</b></a>.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := DihedralGroup( 16 );
&lt;pc group of size 16 with 4 generators&gt;  
gap&gt; DimensionBasis( G );
rec( dimensionBasis := [ f1, f2, f3, f4 ], weights := [ 1, 1, 2, 4 ] )    

</pre></td></tr></table>

<p><a id="X84B7C6A38473722F" name="X84B7C6A38473722F"></a></p>

<h5>4.6-4 LieDimensionSubgroups</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieDimensionSubgroups</code>( <var class="Arg">G</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>list of subgroups</p>

<p>For a finite p-group <var class="Arg">G</var>, returns the series of its Lie dimension subgroups. The m-th Lie dimension subgroup D_(m) is the intersection of the group G and 1+KG^(m), where KG^(m) is the m-th term of the upper Lie power series of KG; see <code class="func">LieUpperNilpotencyIndex</code> (<a href="chap4.html#X87E9411284D1A346"><b>4.5-19</b></a>)</p>


<table class="example">
<tr><td><pre>

gap&gt; G := DihedralGroup( 16 );
&lt;pc group of size 16 with 4 generators&gt;  
gap&gt; LieDimensionSubgroups( G );
[ &lt;pc group of size 16 with 4 generators&gt;, Group([ f3, f4 ]), Group([ f4 ]),
  Group([ &lt;identity&gt; of ... ]) ]     

</pre></td></tr></table>

<p><a id="X7B2EAF81791D6C68" name="X7B2EAF81791D6C68"></a></p>

<h5>4.6-5 LieUpperCodimensionSeries</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieUpperCodimensionSeries</code>( <var class="Arg">KG</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LieUpperCodimensionSeries</code>( <var class="Arg">G</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p><b>Returns: </b>list of subgroups</p>

<p>A notion of upper Lie codimension subgroups was introduced in <a href="chapBib.html#biBCS">[CS06]</a>. For a finite p-group <var class="Arg">G</var>, C_i is the set of all elements g in <var class="Arg">G</var>, such that the Lie commutator [ g, g_1, ..., g_i ] of the length i+1 is equal to zero for all g_1, ..., g_i from <var class="Arg">G</var>, and C_0 = 1. By Du's theorem (see <a href="chapBib.html#biBDu">[Du92]</a>), C_i coincides with the intersection of G and the i-th term of the upper central series 1=Z_0 &lt; Z_1 &lt; Z_2 &lt; ... &lt; Z_n = V(KG) of the normalized unit group V(KG). This fact is used in <strong class="pkg">LAGUNA</strong> to speed up computation of this series. Since V(KG) is involved in computation, for the first time the argiment should be the group ring <var class="Arg">KG</var>, but later you can also apply it to the group <var class="Arg">G</var> itself.</p>


<table class="example">
<tr><td><pre>

gap&gt; G := DihedralGroup(16);
&lt;pc group of size 16 with 4 generators&gt;
gap&gt; KG := GroupRing( GF(2), G );
&lt;algebra-with-one over GF(2), with 4 generators&gt;
gap&gt; LieUpperCodimensionSeries( KG );
[ Group([ f1, f2, f3, f4 ]), Group([ f3, f4, f3*f4 ]), Group([ f4 ]), 
  Group([ f4 ]), Group([  ]) ]
gap&gt; LieUpperCodimensionSeries( G );
[ Group([ f1, f2, f3, f4 ]), Group([ f3, f4, f3*f4 ]), Group([ f4 ]), 
  Group([ f4 ]), Group([  ]) ]

</pre></td></tr></table>

<p><a id="X7E5804B881DE4FF2" name="X7E5804B881DE4FF2"></a></p>

<h5>4.6-6 LAGInfo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LAGInfo</code></td><td class="tdright">( info class )</td></tr></table></div>
<p><code class="code">LAGInfo</code> is a special Info class for <strong class="pkg">LAGUNA</strong> algorithms. It has 5 levels: 0, 1 (default), 2, 3 and 4. To change info level to <code class="code">k</code>, use command <code class="code">SetInfoLevel(LAGInfo, k)</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; SetInfoLevel( LAGInfo, 2 );
gap&gt; KD8 := GroupRing( GF( 2 ), DihedralGroup( 8 ) );
&lt;algebra-with-one over GF(2), with 3 generators&gt;
gap&gt; UD8 := PcNormalizedUnitGroup( KD8 );
#I  LAGInfo: Computing the pc normalized unit group ...
#I  LAGInfo: Calculating weighted basis ...
#I  LAGInfo: Calculating dimension basis ...
#I  LAGInfo: dimension basis finished !
#I  LAGInfo: Weighted basis finished !
#I  LAGInfo: Computing the augmentation ideal filtration...
#I  LAGInfo: Filtration finished !
#I  LAGInfo: finished, converting to PcGroup
&lt;pc group of size 128 with 7 generators&gt;     

</pre></td></tr></table>

<p><a id="X7E812CAB85104F42" name="X7E812CAB85104F42"></a></p>

<h5>4.6-7 LAGUNABuildManual</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LAGUNABuildManual</code>( <var class="Arg"></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This function is used to build the manual in the following formats: DVI, PDF, PS, HTML and text for online help. We recommend that the user should have a recent and fairly complete TeX distribution. Since <strong class="pkg">LAGUNA</strong> is distributed together with its manual, it is not necessary for the user to use this function. Normally it is intended to be used by the developers only. This is the only function of <strong class="pkg">LAGUNA</strong> which requires UNIX/Linux environment.</p>

<p><a id="X86E5260678EDF23D" name="X86E5260678EDF23D"></a></p>

<h5>4.6-8 LAGUNABuildManualHTML</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LAGUNABuildManualHTML</code>( <var class="Arg"></var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>This fuction is used to build the manual only in HTML format. This does not depend on the availability of the TeX installation and works under Windows and MacOS as well. Since <strong class="pkg">LAGUNA</strong> is distributed together with its manual, it is not necessary for the user to use this function. Normally it is intended to be used by the developers only.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap3.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chapBib.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
